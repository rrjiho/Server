## lock
- 공유 자원에 대한 동시 접근을 제어하기 위한 동기화 기법이다.
- 한 번에 오직 하나의 쓰레드만 특정 코드 블록을 실행할 수 있도록 보장한다.

### 기본 동작
- 한 쓰레드가 특정 객체를 잠그고(lock) 다른 쓰레드가 그 객체에 접근 시 잠금 해제할 때까지 기다려야 한다.
- 즉, lock을 사용한 코드 블록은 동시에 두 개 이상의 쓰레드가 실행될 수 없다.
- 다른 쓰레드가 lock이 해제되기를 기다리게 하는 이 메커니즘을 **상호 배제(Mutual Exclusion)** 라고 한다.
- Interlocked는 정수형 값만 반환하며 경량화된 모델이기 때문에 대부분 lock을 사용한다.

```C#
static object _obj = new object(); // 존재만 한다. 데이터 저장 용도 x

    static void Thread_1()
    {
        for(int i = 0; i < 100000; i++)
        {
            // 상호 배제 Mutual Exclusive
            Monitor.Enter(_obj); // 문을 잠구는 행위

            number++;

            Monitor.Exit(_obj); // 잠금을 풀어줌
        }
    }
    
    static void Thread_2()
    {
        for (int i = 0; i < 100000; i++)
        {
            Monitor.Enter(_obj);

            number--;

            Monitor.Exit(_obj);
        }
    }
```
- Monitor
  - `Enter` 문을 잠궈주고 `Exit` 해제한다.
  - 상호 배제 (Mutual Exclusive) ⇒ 나만 사용하겠다.
  - 블럭 안에서는 사실상 싱글 쓰레드라고 생각하면 된다.
  - 만약 블럭 안에서 return 해주면 해제하는 행위가 배제되어 Lock이 풀리지 않는다. DeadLock이 발생한다.
    - 이를 위한 해결책으로 try-finally 구문을 사용할 수 있지만 번거로움을 감수해야 한다.
    - 따라서 대부분 Monitor를 사용하기 보다 이 기능을 포함한 lock을 사용한다.

```C#
static object _obj = new object();
// lock을 걸 객체
// 주로 참조 타입 객체를 사용하며 이 객체는 lock을 사용할 때 동인한 공유 자원을 여러 쓰레드에서 보호하는데 사용됨
static void Thread_1()
{
    for(int i = 0; i < 100000; i++)
    {
        lock (_obj)
        {
            number++;
        }
    }
}

static void Thread_2()
{
    for (int i = 0; i < 100000; i++)
    {
        lock (_obj)
        {
            number--;
        }
    }
}
```   
- lock
  - lock 사용하면 자동으로 Enter - Exit를 수행한다.

### 특징
- 상호 배제(Mutual Exclusion): lock 블록은 한 번에 하나의 쓰레드만 실행할 수 있다.
- 간단한 문법: 동기화를 위한 코드가 간결하며 잠금과 해제를 자동으로 처리해 준다.
- DeadLock 방지: lock 블록 안에서 예외가 발생해도 lock은 블록이 끝나면 자동으로 해제되므로 DeadLock(교착 상태)이 발생하지 않는다.

### 주의할 점
- 잠금 범위 최소화: lock 블록 안에 너무 많은 코드를 넣으면 **성능 저하**가 발생할 수 있다. 잠금이 걸린 동안 다른 쓰레드가 대기해야 하므로 최소한의 코드만 잠그는 것이 좋다.
- 잠금 객체는 참조 타입이어야 함: lock의 대상은 **참조 타입(Reference Type)** 이어야 한다. 주로 lock으로 object 타입 변수를 사용하며 값 타입(Value Type) 또는 문자열은 잠금 객체로 사용하지 않는 것이 좋다. [1]
  - 문자열은 불변(Immutable) 특성 때문에 잠금이 제대로 걸리지 않을 수 있다. (풀링으로 같은 값은 재사용하는 메커니즘)
- 중복 잠금 주의: 동일한 쓰레드에서 동일한 객체를 중복해서 잠그려는 시도가 있으면 데드락이 발생할 수 있다.

***
[1]
- 참조 타입이 아닌 값 타입을 사용하면 복사로 인한 잠금 오류가 발생할 수 있다.
- object는 가장 기본(부모)가 되는 참조 타입이기 때문에 임의의 잠금 객체로 사용하기에 적합하다.
- 고유한 참조 값만 필요할 뿐 데이터 저장 및 다른 용도로 사용하지 않는다.
- object 사용 이유
  - 간단함: 잠금만 필요할 때는 object를 사용하여 고유한 참조 객체를 만드는 것이 가장 간단하고 직관적이다.
  - 효율성: new object()는 매우 가벼운 연산이며, 아무 데이터도 저장하지 않는 빈 객체를 만들기 때문에 불필요한 리소스를 소모하지 않는다.
  - 참조의 고유성: object로 생성된 객체는 고유한 참조를 가지므로 동일한 참조 객체를 사용하는 모든 쓰레드는 정확하게 동일한 자원에 대해 동기화된다.
