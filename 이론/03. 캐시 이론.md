### 캐시 이론

#### 캐시란?
- 캐시는 CPU, 프로그램이 자주 사용하는 데이터를 보다 빠르게 접근할 수 있는 메모리 공간에 저장해 두는 것이다.
- CPU는 데이터를 쓰거나 가져오기 위해 여러 단계의 메모리 계층 구조를 갖는다.
  - 레지스터: 가장 빠르지만 용량이 매우 적은 CPU 내부 메모리
  - 캐시 메모리: CPU와 메인 메모리(RAM) 사이에 위치한 임시 저장 공간으로 속도가 매우 빠름
  - RAM: 상대적으로 느리지만 더 큰 데이터를 저장할 수 있는 공간
 - 캐싱의 핵심은 자주 사용되거나 최근에 사용된 데이터를 메모리보다 더 빠른 레지스터나 캐시 메모리에 임시 저장하여 성능을 높이는 것이다.

#### 캐시된 값이란?
- 예로, 이전 컴파일러 최적화에서 `_stop` 변수를 여러번 사용한다고 가정한다면
- RAM에서 매번 변수를 읽어오면 속도가 느리기 때문에 CPU는 그 값을 한 번 메모리에서 가져온 후 레지스터나 캐시 메모리에 저장해 둔다.
- 이 저장된 값을 계속 사용하게 되는데 이것을 캐시된 값이라고 한다.

#### 캐시 이론
```C#
class Program
{

    static void Main(string[] args)
    {
        int[,] arr = new int[10000, 10000];

        {
            long now = DateTime.Now.Ticks;
            for (int y = 0; y < 10000; y++)
                for (int x = 0; x < 10000; x++)
                    arr[y, x] = 1;
            long end = DateTime.Now.Ticks;
            Console.WriteLine($"(y, x) 순서 걸린 시간 {end - now}");
        }

        {
            long now = DateTime.Now.Ticks;
            for (int y = 0; y < 10000; y++)
                for (int x = 0; x < 10000; x++)
                    arr[x, y] = 1;
            long end = DateTime.Now.Ticks;
            Console.WriteLine($"(x, y) 순서 걸린 시간 {end - now}");
        }
    }
}
```
- 직관적으로 보았을 때 같은 시간이 걸릴 것이라 예상하지만 두 번째 배열을 구성하는데 더 오랜 시간이 걸린다.

- 어떤 변수나 데이터를 변경할 때 바로 RAM에 올리는 것이 아니라 캐시 장치를 거쳐서 올라가는데 이때 데이터를 한 번에 모아서 효율적으로 RAM에 올리고 싶어한다. ⇒ 캐시 이론
  - Temporal Locality: 시간적으로 예측을 해서 효율성을 올리는 것
  - Spacial Locality: 공간적으로 예측을 해서 효율성을 올리는 것

- 위 배열을 살펴보면 공간적으로 예측을 해서 효율성을 올렸다.
- 예를 들어 5 * 5 배열이라고 한다면
  - [][][][][] [][][][][] [][][][][] [][][][][] [][][][][] 앞의 5개 정도를 캐시에 올려 놓고 변경하는 것이라고 생각하면 된다.
  - 따라서 첫 번째 배열은 효율적으로 값을 변경할 수 있었고
  - 두 번째 배열은 캐시에 올려 놓은 그 배열을 사용하지 않으므로 조금 시간이 오래 걸린 것이다.
